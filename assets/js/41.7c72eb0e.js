(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{567:function(n,t,r){n.exports=r.p+"assets/img/1.1.9d7723ab.png"},793:function(n,t,r){"use strict";r.r(t);var a=r(42),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"_1-1-字符串性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-字符串性能优化"}},[n._v("#")]),n._v(" 1.1 字符串性能优化")]),n._v(" "),a("h2",{attrs:{id:"_1-1-1-string对象是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-string对象是如何实现的"}},[n._v("#")]),n._v(" 1.1.1 String对象是如何实现的？")]),n._v(" "),a("p",[n._v("在 Java 语言中，Sun 公司的工程师们对 String 对象做了大量的优化，来节约内存空间，\n提升 String 对象在系统中的性能。一起来看看优化过程，如下图所示：")]),n._v(" "),a("p",[a("img",{attrs:{src:r(567),alt:""}})]),n._v(" "),a("ol",[a("li",[a("strong",[n._v("在 Java6 以及之前的版本中")]),n._v("，String 对象是对 char 数组进行了封装实现的对象，主要\n有四个成员变量：char 数组、偏移量 offset、字符数量 count、哈希值 hash。 String 对象是通过 offset 和 count 两个属性来定位 char[] 数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。")]),n._v(" "),a("li",[a("strong",[n._v("从 Java7 版本开始到 Java8 版本")]),n._v("，Java 对 String 类做了一些改变。String 类中不再有\noffset 和 count 两个变量了。这样的好处是 String 对象占用的内存稍微少了些，同时，\nString.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问\n题 。")]),n._v(" "),a("li",[a("strong",[n._v("从 Java9 版本开始")]),n._v("，工程师将 char[] 字段改为了 byte[] 字段，又维护了一个新的属性\ncoder，它是一个编码格式的标识")])]),n._v(" "),a("p",[a("strong",[n._v("工程师为什么这样修改呢？")]),n._v("\n我们知道一个 char 字符占 16 位，2 个字节。这个情况下，存储单字节编码内的字符（占\n一个字节的字符）就显得非常浪费。JDK1.9 的 String 类为了节约内存空间，于是使用了占\n8 位，1 个字节的 byte 数组来存放字符串。\n而新属性 coder 的作用是，在计算字符串长度或者使用 indexOf（）函数时，我们需要根\n据这个字段，判断如何计算字符串长度。coder 属性默认有 0 和 1 两个值，0 代表 Latin-\n1（单字节编码），1 代表 UTF-16。如果 String 判断字符串只包含了 Latin-1，则 coder\n属性值为 0，反之则为 1。")]),n._v(" "),a("p",[a("strong",[n._v("Java 这样做的好处在哪里呢？")]),n._v("\n第一，保证 String 对象的安全性。假设 String 对象是可变的，那么 String 对象将可能被\n恶意修改。\n第二，保证 hash 属性值不会频繁变更，确保了唯一性，使得类似 HashMap 容器才能实\n现相应的 key-value 缓存功能。\n第三，可以实现字符串常量池。在 Java 中，通常有两种创建字符串对象的方式，一种是通\n过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的\n创建，如 String str = new String(“abc”)。\n"),a("strong",[n._v("当代码中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池\n中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少\n同一个值的字符串对象的重复创建，节约内存。")]),n._v('\nString str = new String(“abc”) 这种方式，首先在编译类文件时，"abc"常量字符串将\n会放入到常量结构中，在类加载时，“abc"将会在常量池中创建；其次，在调用 new 时，\nJVM 命令将会调用 String 的构造函数，同时引用常量池中的"abc” 字符串，在堆内存中\n创建一个 String 对象；最后，str 将引用 String 对象')])])}),[],!1,null,null,null);t.default=s.exports}}]);